[{"content":"A. Tricky Template 我们对每个位置 $i$ 来看,只要 $a_i == c_i \\ or \\ b_i == c_i$​ ,那么就会使其不成立, 如果是整个字符串呢，那么就是，那么就需要每个位置都成立才能使其不成立，于是遍历判断一下即可\n$code:$\nvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::string a, b, c; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; int ok = 0; for(int i = 0; i \u0026lt; n; i ++ ) { if(a[i] != c[i] \u0026amp;\u0026amp; b[i] != c[i]) { ok = 1; } } std::cout \u0026lt;\u0026lt; (ok ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } B. Forming Triangles 首先题目给的 长度是 $2^{a_i}$ ,我们观察一下，发现能构成三角形的边长只有这种情况 $(2^n, 2^n, 2^k) (其中 k \\le n)$ ，那么我们就直接计数即可，特判一下 $k == n$ 的情况，我们计算贡献，记录 $2^n$ 的个数为x, 小于 $2^n$ 的个数为 $s$，对于 $k == n: \\tbinom{x}{3}$ , 对于 $k \u0026lt; n:\\tbinom{x}{2} * s$，求个前缀和统计贡献即可\n$code:$\nvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::map\u0026lt;int, int\u0026gt; mp; for(int i = 0; i \u0026lt; n; i ++ ) { int x; std::cin \u0026gt;\u0026gt; x; mp[x] ++; } o i64 ans = 0, s = 0; for(auto [x, y] : mp) { if(y \u0026gt;= 3) { ans += 1LL * y * (y - 1) * (y - 2) / 3 / 2; } if(y \u0026gt;= 2) { ans += 1LL * y * (y - 1) / 2 * s; } s += y; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } C. Closest Cities 我们分别记录从 $1$ 走到 $i$ 的代，以及从 $n$ 走到 $i$ 的代价，就是一个前缀和后缀，然后判断一下每个路径的取值，最后查询就减去即可\n$code:$\nvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; a(n); for(int i = 0; i \u0026lt; n; i ++ ) { std::cin \u0026gt;\u0026gt; a[i]; } std::vector\u0026lt;i64\u0026gt; pre(n), suf(n); pre[1] = 1; for(int i = 1; i \u0026lt; n - 1; i ++ ) { pre[i + 1] = pre[i] + (a[i + 1] - a[i] \u0026lt; a[i] - a[i - 1] ? 1 : a[i + 1] - a[i]); } suf[n - 2] = 1; for(int i = n - 2; i \u0026gt;= 1; i -- ) { suf[i - 1] = suf[i] + (a[i] - a[i - 1] \u0026lt; a[i + 1] - a[i] ? 1 : a[i] - a[i - 1]); } int q; std::cin \u0026gt;\u0026gt; q; while(q -- ) { int x, y; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x --, y --; if(x \u0026lt; y) { std::cout \u0026lt;\u0026lt; pre[y] - pre[x] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } else { std::cout \u0026lt;\u0026lt; suf[y] - suf[x] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } D. Berserk Monsters 观察到如果一个怪兽被消灭，那么受影响的只有与之相邻的俩个怪兽，其余的都不会改变，链表模拟这个过程即可，设每次删除的怪兽为$x_i$ 那么 复杂度大致为 $2(x_1 + x_2+\u0026hellip;+x_n) = 2n$ ，然后可以用 $set$ 去维护，多一个 $log(n)$ 的复杂度，总复杂度为 $O(nlogn)$\n$code:$\nvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; a(n + 2), d(n + 2), l(n + 2), r(n + 2), del(n + 2); for(int i = 1; i \u0026lt;= n; i ++ ) { std::cin \u0026gt;\u0026gt; a[i]; } for(int i = 1; i \u0026lt;= n; i ++ ) { std::cin \u0026gt;\u0026gt; d[i]; } std::queue\u0026lt;int\u0026gt; q, _q; for(int i = 1; i \u0026lt;= n; i ++ ) { r[i] = i + 1; l[i] = i - 1; q.push(i); } l[n + 1] = n; r[0] = 1; std::vector\u0026lt;int\u0026gt; ans; for(int i = 0; i \u0026lt; n; i ++ ) { std::queue\u0026lt;int\u0026gt; _q; while(!q.empty()) { int pos = q.front(); q.pop(); int v = a[l[pos]] + a[r[pos]]; if(v \u0026gt; d[pos]) { _q.push(pos); } } std::set\u0026lt;int\u0026gt; S; ans.push_back(_q.size()); while(!_q.empty()) { auto u = _q.front(); _q.pop(); del[u] = true; if(l[u] \u0026gt;= 1 \u0026amp;\u0026amp; l[u] \u0026lt;= n) S.insert(l[u]); if(r[u] \u0026gt;= 1 \u0026amp;\u0026amp; r[u] \u0026lt;= n) S.insert(r[u]); r[l[u]] = r[u]; l[r[u]] = l[u]; } for(auto x : S) { if(!del[x]) { q.push(x); } } } for(auto x : ans) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"/posts/acm/educational-codeforces-round-161-rated-for-div.-2/","summary":"A. Tricky Template 我们对每个位置 $i$ 来看,只要 $a_i == c_i \\ or \\ b_i == c_i$​ ,那么就会使其不成立, 如果是整个字符串呢，那么就是，那么就需要每个位置都成立才能使其不成立，于是遍历判断一下即可 $code:$ void solve() { int n; std::cin \u0026gt;\u0026gt; n; std::string a, b, c; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; int ok = 0; for(int i = 0; i \u0026lt; n; i ++ ) { if(a[i] != c[i] \u0026amp;\u0026amp; b[i] != c[i]) { ok = 1; } } std::cout \u0026lt;\u0026lt; (ok ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;)","title":"Educational Codeforces Round 161 (Rated for Div. 2) A-E"},{"content":"牛客周赛Round31 A.小红小紫替换 判断即可\n$code:$\nvoid solve() { std::string s; std::cin \u0026gt;\u0026gt; s; std::cout \u0026lt;\u0026lt; (s == \u0026#34;kou\u0026#34; ? \u0026#34;yukari\u0026#34; : s) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } B.小红的因子数 看到数据范围为 $1e13$，$\\sqrt{1e13} \\approx 3e6$ 所以直接枚举根号以内的素因子即可\n复杂度 $O(\\sqrt{n})$\n$code:$\nvoid solve() { i64 x; std::cin \u0026gt;\u0026gt; x; int ans = 0; for(int i = 2; i \u0026lt;= x / i; i ++ ) { if(x % i == 0) { while(x % i == 0) { x /= i; } ans ++; } } ans += x \u0026gt; 1; std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } C.小红的字符串中值 首先观察到，中值左右俩边的字符数量一定相等，然后我们只需要枚举$S$中每一个等于询问字符的位置，然后计算左右两边能取到多少即可\nvoid solve() { int n; char o; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; o; std::string s; std::cin \u0026gt;\u0026gt; s; i64 ans = 0; for(int i = 0; i \u0026lt; n; i ++ ) { if(s[i] == o) { i64 l = i, r = n - i - 1; ans += std::min(l, r) + 1; } } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } D.小红数组操作 模拟链表即可，每个数维护一个节点，记录左右相连的值，模拟操作\nvoid solve() { int q; std::cin \u0026gt;\u0026gt; q; std::map\u0026lt;int, int\u0026gt; l, r; r[0] = -1; int siz = 0; while(q -- ) { int op, x, y; std::cin \u0026gt;\u0026gt; op; if(op == 1) { std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; r[x] = r[y]; l[x] = y; l[r[y]] = x; r[y] = x; siz ++; } else { std::cin \u0026gt;\u0026gt; x; r[l[x]] = r[x]; l[r[x]] = l[x]; siz --; } } std::cout \u0026lt;\u0026lt; siz \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int now = r[0]; while(now != -1) { std::cout \u0026lt;\u0026lt; now \u0026lt;\u0026lt; \u0026#39; \u0026#39;; now = r[now]; } } E.小红数组操作 因为数据范围比较小，我们能想到 $dp$，我们定义 $dp_i$ 表示的是所有元素和为 $i$ 时选择的元素数量最小为多少，对于每个数字有选和不选俩种情况，记录选择上一位选完的状态为 $dp$ ，当前位的状态为 $_dp$ ，当前状态能由上一位推出，并且没有影响，我们枚举上一位有的情况，然后对于 $a_i$ 选和不选俩种情况更新 $_dp$，实际上就是滚动数组，也可以记录位置，用二维 $dp$ ，同理 $$ 选：_dp[i - a[pos]] = std::min(_dp[i - a[pos]], dp[i] + 1) \\newline 不选：_dp[i + a[pos]] = std::min(_dp[i + a[pos]], dp[i]); \\newline 注意：这里如果 _dp 中没有这个元素就直接更新 $$ $code:$\nvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; a(n); for(int i = 0; i \u0026lt; n; i ++ ) { std::cin \u0026gt;\u0026gt; a[i]; } std::map\u0026lt;int, int\u0026gt; dp; dp[0] = 0; for(int i = 0; i \u0026lt; n; i ++ ) { std::map\u0026lt;int, int\u0026gt; _dp; for(auto [v, y] : dp) { if(!_dp.count(v - a[i])) { _dp[v - a[i]] = y + 1; } else { _dp[v - a[i]] = std::min(_dp[v - a[i]], y + 1); } if(!_dp.count(v + a[i])) { _dp[v + a[i]] = y; } else { _dp[v + a[i]] = std::min(_dp[v + a[i]], y); } } dp = _dp; } std::cout \u0026lt;\u0026lt; (dp.count(0) ? dp[0] : -1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } F.小红的连续段 $code:$\nvoid solve() { int x, y; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; static constexpr int P = 1e9 + 7; std::vector\u0026lt;i64\u0026gt; fac(1001), invfac(1001), inv(1001); fac[0] = invfac[0] = fac[1] = invfac[1] = inv[1] = 1; for(int i = 2; i \u0026lt;= 1000; i ++ ) { inv[i] = (P - P / i * inv[P % i] % P) % P; fac[i] = fac[i - 1] * i % P; invfac[i] = invfac[i - 1] * inv[i] % P; } auto C = [\u0026amp;](i64 n, i64 m) -\u0026gt; i64 { if(m \u0026gt; n) return 0; return fac[n] * invfac[n - m] % P * invfac[m] % P; }; std::vector\u0026lt;i64\u0026gt; ans(x + y + 1); for(int i = 1; i \u0026lt;= x - 1; i ++ ) { ans[2 * i + 1] = (ans[2 * i + 1] + C(x - 1, i) * C(y - 1, i - 1) % P) % P; } for(int i = 0; i \u0026lt;= x - 1; i ++ ) { ans[2 * i + 2] = (ans[2 * i + 2] + C(x - 1, i) * C(y - 1, i) % P) % P; } for(int i = 1; i \u0026lt;= y - 1; i ++ ) { ans[2 * i + 1] = (ans[2 * i + 1] + C(y - 1, i) * C(x - 1, i - 1) % P) % P; } for(int i = 0; i \u0026lt;= x - 1; i ++ ) { ans[2 * i + 2] = (ans[2 * i + 2] + C(y - 1, i) * C(x - 1, i) % P) % P; } for(int i = 1; i \u0026lt;= x + y; i ++ ) { std::cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","permalink":"/posts/acm/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9Bround31/","summary":"牛客周赛Round31 A.小红小紫替换 判断即可 $code:$ void solve() { std::string s; std::cin \u0026gt;\u0026gt; s; std::cout \u0026lt;\u0026lt; (s == \u0026#34;kou\u0026#34; ? \u0026#34;yukari\u0026#34; : s) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } B.小红的因子数 看到数据范围为 $1e13$，$\\sqrt{1e13} \\approx 3e6$ 所以直接枚举根号以内的素因子即可 复杂度 $O(\\sqrt{n})$ $code:$ void solve() { i64 x; std::cin \u0026gt;\u0026gt; x; int ans = 0; for(int i = 2; i \u0026lt;= x / i; i ++ ) { if(x % i == 0) { while(x % i == 0) { x /=","title":"牛客周赛Round31"},{"content":"组合数学 排列与组合 1.帕斯卡公式 $$ 对于所有满足 1\\le k \\le n-1的整数 n 和 k,有 \\newline \\tbinom{n}{k} = \\tbinom{n - 1}{k} + \\tbinom{n - 1}{k - 1} $$\n2.定理 $$ 1. 设多重集合S，有k种类型对象，每一种类型的有限出现次数时n_1,n_2,\u0026hellip;,n_k,设S的大小为 n, S的排列数为 \\newline \\frac{n!}{n_1!n_2!\u0026hellip;n_k!} \\newline 2.设S为有k种类型的多重集合,每种元素有无限个,S的r组合个数等于 \\newline \\tbinom{r+k-1}{r} $$\n","permalink":"/posts/acm/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","summary":"组合数学 排列与组合 1.帕斯卡公式 $$ 对于所有满足 1\\le k \\le n-1的整数 n 和 k,有 \\newline \\tbinom{n}{k} = \\tbinom{n - 1}{k} + \\tbinom{n - 1}{k - 1} $$ 2.定理 $$ 1. 设多重集合S，有k种类型对象，每一种类型的有限出现次数时n_1,n_2,\u0026hellip;,n_k,设S的大小为 n, S的排列数为 \\newline \\frac{n!}{n_1!n_2!\u0026hellip;n_k!} \\newline 2.设S为有k种类型的多重集合,每种元","title":"组合数学"},{"content":"hello $$ \\frac{a_i^{j}}{n} $$\n","permalink":"/posts/acm/blog/","summary":"hello $$ \\frac{a_i^{j}}{n} $$","title":"Blog"},{"content":" \u0026lt; friend name=\u0026ldquo;Sulv\u0026rsquo;s Blog\u0026rdquo; url=\u0026ldquo;https://www.sulvblog.cn\u0026rdquo; logo=\u0026ldquo;https://www.sulvblog.cn/img/Q.gif\u0026quot; word=\u0026ldquo;一个记录技术、阅读、生活的博客\u0026rdquo; \u0026gt;\n👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"/links/","summary":"\u0026lt; friend name=\u0026ldquo;Sulv\u0026rsquo;s Blog\u0026rdquo; url=\u0026ldquo;https://www.sulvblog.cn\u0026rdquo; logo=\u0026ldquo;https://www.sulvblog.cn/img/Q.gif\u0026quot; word=\u0026ldquo;一个记录技术、阅读、生活的博客\u0026rdquo; \u0026gt; 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\n名字: shift 职业: 学生 爱好: 不知道 ","permalink":"/about/","summary":"关于我 名字: shift 职业: 学生 爱好: 不知道","title":"🙋🏻‍♂️关于"}]